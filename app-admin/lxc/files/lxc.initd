#!/sbin/runscript
# Copyright 1999-2009 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: $

description="Operate LinuX Containers on boot and shutdown"

depend() {
	after net
}

make_vars() {
	: ${LXC_ROOT:=/var/lib/lxc}
	: ${LXC_AUTOBOOT:=autoboot}

	: ${LXC_START:=/usr/sbin/lxc-start}
	: ${LXC_STOP:=/usr/sbin/lxc-stop}

	: ${LXC_INFO:=/usr/sbin/lxc-info}

	: ${LXC_STOP_TIMEOUT:=30}

        [ -n "${LXC_PARALLEL}" ] && return

	# Taken from OpenVZ init.d

        LXC_PARALLEL=`awk '
	BEGIN { num=0; }
	$1 == "processor" { num++; }
	END { print num * 4; }' /proc/cpuinfo`
}

want_autostart() {
	local name=$1

	local flag="${LXC_ROOT}/${name}/${LXC_AUTOBOOT}"

	[[ -f "${flag}" ]] && return 0

	return 1
}

lxc_list() {
	local state=$1
	
	if [[ -z "${state}" ]]; then
		find "${LXC_ROOT}" -maxdepth 1 -type d \
			-not -path "${LXC_ROOT}" -printf "%f\n"
	else
		local container=

		for container in $(lxc_list); do
			${LXC_INFO} --name "${container}"	|  \
				grep -q "${state}$"		&& \
					echo "${container}"
		done
	fi
}

lxc_select_random() {
	echo "$@" | awk "{ print \$$(( $RANDOM % $# + 1 )); }"
}

lxc_threads=0
lxc_names=

lxc_wait_slot() {
	local container=$(lxc_select_random ${lxc_names})

	eval local waitpid=\${lxc_pid_${container}}

	[[ -n "${waitpid}" ]] && wait ${waitpid}

	lxc_threads=$(( $lxc_threads - 1 ));
	lxc_names=$( echo "${lxc_names}" | sed -e "s/${container}//" \
			-r -e 's/(^ | $)//g; s/ +/ /g')
	eval unset lxc_pid_${container}

	return 0
}

lxc_threaded() {
	local name=$1; shift;

	local run="$@"

	while [[ ${lxc_threads} -gt ${LXC_PARALLEL} ]]; do
		lxc_wait_slot
	done

	lxc_threads=$(( $lxc_threads + 1 ));
	lxc_names="${lxc_names} ${name}"

	${run} &

	eval lxc_pid_${container}=$!
}

lxc_run() {
	local prerun_msg=$1 fail_msg=$2; shift; shift;

	local run="$@"

	einfo "LXC ${name}: ${prerun_msg}"

	local err=$( ${run} 2>&1 )

	local ret=$?

	[[ ${ret} -eq 0 ]] && return 0

	eerror "LXC ${name}: ${fail_msg}:"

	local line=
	echo -e "${err}" | while read -r line; do
		eerror "LXC ${name}: ${line}"
	done

	return ${ret}
}

lxc_start() {
	local container=$1

	lxc_run "launching" "start failed" \
		${LXC_START} --name "${container}" -d
	
	local ret=$?

	return ${ret}
}

start() {
	make_vars

	ebegin "Autostarting LXCs with '${LXC_AUTOBOOT}' flag"

	eindent
	
	local container=
	for container in $(lxc_list); do
		want_autostart "${container}" || continue;
		${LXC_INFO} -n "${container}" | grep -q 'RUN' && continue;

		lxc_threaded "${container}" lxc_start "${container}"
	done

	while [[ -n "${lxc_names}" ]]; do
		lxc_wait_slot
	done

	eoutdent

	eend $?
}

lxc_stop_hook_sysvinit() {
	local name=$1
	local initpid=$(lxc-ps --name ${name} -C init | \
			grep 'init$' | awk '{ print $2; }' | sed 's/ //g')

	[[ -z "${initpid}" ]] && return 1

	local inittab="/proc/${initpid}/root/etc/inittab"

	local magic_string="ca:12345:ctrlaltdel:/sbin/shutdown -hP now"

	if ! grep -q "${magic_string}" "${inittab}"; then
		sed -r 's/^(.*:ctrlaltdel:)/#\1/' -i ${inittab}

		echo "${magic_string}" >> ${inittab}
	fi

	# Ensure that SIGINT will shutdown container
	kill -HUP ${initpid}
	kill -INT ${initpid}

	# This will wait untill all childs will die, but, generally, this
	# doesn't mean that rc finishes it's work. But, at least, all
	# significant data will not be lost.

	# Also, in case of openrc, any opened shell or agetty will die at
	# very final states, so if we have agetty into inittab it will ensure
	# that all work is done (kill all processes - it's last what openrc may
	# do inside container)
	while true; do
		local childs=$(ps --ppid ${initpid} -o pid h)

		[[ -z "${childs}" ]] && break;

		local waitpid=$(lxc_select_random ${childs})

		# One big dirty hack to prevent deadlock if container stucked

		echo "${waitpid}" | start-stop-daemon --stop \
			--pidfile /proc/self/fd/0 \
			--retry SIGCHLD/${LXC_STOP_TIMEOUT} &> /dev/null

		[[ $? -eq 0 ]] && return 0
		
		eerror "LXC ${name}: init timed out: forcing shutdown"

		return 1
	done
}

lxc_stop() {
	local container=$1

	einfo "LXC ${container}: sending shutdown command to container's init"

	if type lxc_stop_hook &>/dev/null; then
		lxc_stop_hook "${container}"
	else
		lxc_stop_hook_sysvinit "${container}"
	fi

	lxc_run "really stopping" "stop failed" \
		${LXC_STOP} --name "${container}"

	local ret=$?

	return ${ret}
}

stop() {
	make_vars

	ebegin "Stopping all started LXCs"

	eindent

	for container in $(lxc_list RUNNING); do
		lxc_threaded "${container}" lxc_stop "${container}"
	done

	while [[ -n "${lxc_names}" ]]; do
		lxc_wait_slot
	done

	eoutdent

	eend $?
}

lxc_restart() {
	local name=$1

	lxc_stop && lxc_start
}

restart() {
	make_vars

	ebegin "Restarting all started LXCs"

	eindent

	for container in $(lxc_list RUNNING); do
		lxc_threaded "${container}" lxc_restart "${container}"
	done

	while [[ -n "${lxc_names}" ]]; do
		lxc_wait_slot
	done

	eoutdent

	eend $?
}
